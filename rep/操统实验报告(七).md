



<center>实验课程:______________操作系统____________</center>

<center>实验名称:________lab6 并发与锁机制__________</center>

<center>专业名称:______计算机科学与技术（系统结构）________________</center>

<center>学生姓名:_______彭晨晗___________________</center>

<center>学生学号:_______20337228_____________</center>

<center>实验成绩:__________________________________________</center>

<center>报告时间:________2022.5.10______________</center>





### （一）实验要求

#### 实验目标：

在本次实验中，我们首先使用硬件支持的原子指令来实现自旋锁SpinLock，自旋锁将成为实现线程互斥的有力工具。接着，我们使用SpinLock来实现信号量，最后我们使用SpinLock和信号量来给出两个实现线程互斥的解决方案。

#### 实验任务：

Assignment 1 代码复现题
1.1 代码复现

在本章中，我们已经实现了自旋锁和信号量机制。现在，同学们需要复现教程中的自旋锁和信号量的实现方法，并用分别使用二者解决一个同步互斥问题，如消失的芝士汉堡问题。最后，将结果截图并说说你是怎么做的。
1.2 锁机制的实现

我们使用了原子指令xchg来实现自旋锁。但是，这种方法并不是唯一的。例如，x86指令中提供了另外一个原子指令bts和lock前缀等，这些指令也可以用来实现锁机制。现在，同学们需要结合自己所学的知识，实现一个与本教程的实现方式不完全相同的锁机制。最后，测试你实现的锁机制，将结果截图并说说你是怎么做的。
Assignment 2 生产者-消费者问题
2.1 Race Condition

同学们可以任取一个生产者-消费者问题，然后在本教程的代码环境下创建多个线程来模拟这个问题。在2.1中，我们不会使用任何同步互斥的工具。因此，这些线程可能会产生冲突，进而无法产生我们预期的结果。此时，同学们需要将这个产生错误的场景呈现出来。最后，将结果截图并说说你是怎么做的。
2.2 信号量解决方法

使用信号量解决上述你提出的生产者-消费者问题。最后，将结果截图并说说你是怎么做的。
Assignment 3 哲学家就餐问题

假设有 5 个哲学家，他们的生活只是思考和吃饭。这些哲学家共用一个圆桌，每位都有一把椅子。在桌子中央有一碗米饭，在桌子上放着 5 根筷子。

哲学家就餐问题

当一位哲学家思考时，他与其他同事不交流。时而，他会感到饥饿，并试图拿起与他相近的两根筷子（筷子在他和他的左或右邻居之间）。一个哲学家一次只能拿起一根筷子。显然，他不能从其他哲学家手里拿走筷子。当一个饥饿的哲学家同时拥有两根筷子时，他就能吃。在吃完后，他会放下两根筷子，并开始思考。
3.1 初步解决方法

同学们需要在本教程的代码环境下，创建多个线程来模拟哲学家就餐的场景。然后，同学们需要结合信号量来实现理论课教材中给出的关于哲学家就餐问题的方法。最后，将结果截图并说说你是怎么做的。
3.2 死锁解决方法

虽然3.1的解决方案保证两个邻居不能同时进食，但是它可能导致死锁。现在，同学们需要想办法将死锁的场景演示出来。然后，提出一种解决死锁的方法并实现之。最后，将结果截图并说说你是怎么做的。

## （二）实验过程

1. 阅读lab6Assignment下面的知识，编写简单的示例实现
1. 完成任务1
1. 完成生产者消费者问题
1. 更换锁机制
1. 完成信号量的例子
1. 完成哲学家问题

##   (三) 关键代码

### 一.**任务1**

这部分的代码主要参考样例，学习为主

### 二.锁机制

```cpp
asm_atomic_exchange:
	push 	ebp
	mov	ebp,esp
	pushad

	mov	eax,[ebp + 4*2]
	mov	ebx,[ebp + 4*3]
	lock 	mov	ecx,[eax]
	lock 	mov	edx,[ebx]
	lock	mov	[eax],edx
	lock	mov	[ebx],ecx

	popad
	pop	ebp
	ret 
```

用lock前缀去完成原子指令

### 三. 生产者消费者问题

通过信号量来解决

关于问题的产生用图片来阐释

```cpp
void producer(void *arg)
{
        for(int i = 0; i < 10;++i)
        {
                printf("produce one\n");
                space.P();
                lag ++;
                num.V();
        }
}

void consumer(void *arg)
{
        for(int i = 0;i<10;++i)
        {
                printf("consumer\n");
                num.P();
                lag--;
                space.V();
                int delay= 0xfffffff;
                while(delay)
                {
                        --delay;
                }
        }

}

```

### 四.哲学家问题

这里只展现其中一个哲学家，其余的4位同这个代码类似

这里展现的是用一个数组去保护信号量，防止死锁的出现，关于死锁的问题，在下一部分展示

```c++
int is_token[5];
void philosopher0(void *arg){
        do
        {
                if(is_token[0] ==0 && is_token[1] ==0) {

                printf("NO.0 wants to take the chopstic in his left side.\n");
                chopsticks[0].P();
                is_token[0] = 1;
                printf("NO.1 successfully took the chopstic in his left side.\n");

                printf("NO.1 wants to take the chopstic in his right side.\n");
                chopsticks[1].P();
                is_token[1] = 1;
                printf("No.1 successfully took the chopstic in his right side.\n");

                printf("No.1 start eating.\n");
                int delay = 0xfffffff;
                while (delay) --delay;

                printf("No.1 start thinking.\n");
                chopsticks[0].V();
                is_token[0] = 0;
                chopsticks[1].V();
                is_token[1] = 0;
                return ;
                }
        }while(1);
}

```




## (四) 实验结果

1. 任务一复现

​	首先是对锁机制的复现，发现吃汉堡问题能够解决![锁机制](C:\Users\86139\Desktop\截图\锁机制.png)

信号量的复现，结果也是正常的

![信号量复现](C:\Users\86139\Desktop\截图\信号量复现.png)



自旋锁本身的部分

![自旋锁复现](C:\Users\86139\Desktop\截图\自旋锁复现.png)

生产者问题的出现

可以看出，不能正常的生产与消费

![生产者](C:\Users\86139\Desktop\截图\生产者.png)

生产者问题解决

通过信号量的方式开仓库与存量，满了就等待

![生产者解决](C:\Users\86139\Desktop\截图\生产者解决.png)

哲学家问题用信号量初步解决的截图

![死锁状态](C:\Users\86139\Desktop\截图\死锁状态.png)

死锁状态的解决方法是保证左右的筷子在的话才能执行，否则就一直等待

![死锁解除](C:\Users\86139\Desktop\截图\死锁解除.png)

## （五）总结

本次实验做的比较慢，关于死锁卡了很久，代码也比较长。但是通过这次的学习，结合书本同步的那一章的学习，对于这部分的内容有了更深入的理解。开始时在多线程部分也做了一些更多线程的尝试，然后相应的用锁机制与信号量去保证他们的同步信息是有效的。通过这次学习，对于内容有了更优秀的理解。 
